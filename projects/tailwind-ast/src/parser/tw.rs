// This file was generated by Peginator v0.3.0
// Hash of the grammar file: 7DA935249182A1EC275B4B9505E517F41E941BB12054567226E9E73EF5C09B70
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct TwParser {
    pub statements: Vec<TwStatementNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum TwStatementNode {
    GroupNode(GroupNode),
    InstructNode(InstructNode),
}
#[derive(Debug, Clone)]
pub struct GroupNode {
    pub head: InstructNode,
    pub statements: Vec<TwStatementNode>,
    pub important: Option<Important>,
}
#[derive(Debug, Clone)]
pub struct InstructNode {
    pub instructs: Vec<IdentifierNode>,
    pub important: Option<Important>,
}
pub type Hyphen = char;
pub type Important = char;
pub type IdentifierNode = String;
pub type Dot = char;
pub type Split = char;
impl peginator_generated::PegParser for TwParser {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_TwParser(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{
        IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod TwParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut statements, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<TwStatementNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwParser> {
            let result = parse(state, tracer, cache)?.map(|r| super::TwParser { statements: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwParser<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwParser> {
        tracer.run_traced("TwParser", state, |state, tracer| {
            TwParser_impl::rule_parser(state, tracer, cache)
        })
    }
    mod TwStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GroupNode(state, tracer, cache))
                        .map_inner(Parsed__override::GroupNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_InstructNode(state, tracer, cache))
                        .map_inner(Parsed__override::InstructNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::TwStatementNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwStatementNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwStatementNode> {
        tracer.run_traced("TwStatementNode", state, |state, tracer| {
            TwStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod GroupNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: head, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_InstructNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: mut statements, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { head, statements, important }, state })
        }
        pub struct Parsed {
            pub head: InstructNode,
            pub statements: Vec<TwStatementNode>,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GroupNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::GroupNode {
                head: r.head,
                statements: r.statements,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GroupNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GroupNode> {
        tracer.run_traced("GroupNode", state, |state, tracer| {
            GroupNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod InstructNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                        .discard_result()?;
                    let ParseOk { result: mut instructs, state } =
                        parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| {
                                parse_IdentifierNode(state, tracer, cache)
                            })
                            .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: instructs, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut instructs: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            instructs.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: instructs, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut instructs, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_instructs_with, state } =
                part_1::parse(state, tracer, cache)?;
            instructs.extend(extend_instructs_with);
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { instructs, important }, state })
        }
        pub struct Parsed {
            pub instructs: Vec<IdentifierNode>,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::InstructNode> {
            let result = parse(state, tracer, cache)?
                .map(|r| super::InstructNode { instructs: r.instructs, important: r.important });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_InstructNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, InstructNode> {
        tracer.run_traced("InstructNode", state, |state, tracer| {
            InstructNode_impl::rule_parser(state, tracer, cache)
        })
    }
    #[inline]
    pub(super) fn parse_Hyphen<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Hyphen> {
        if let Ok(result) = parse_character_literal(state.clone(), '-') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Hyphen" }))
    }
    #[inline]
    pub(super) fn parse_Important<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Important> {
        if let Ok(result) = parse_character_literal(state.clone(), '-') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Important" }))
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, IdentifierNode> {
        match crate::eat_css_class(state.s()) {
            Ok((result, advance)) => {
                Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) })
            }
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed {
                function_name: "crate::eat_css_class",
                error_string,
            })),
        }
    }
    #[inline]
    pub(super) fn parse_Dot<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Dot> {
        if let Ok(result) = parse_character_literal(state.clone(), '.') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '。') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Dot" }))
    }
    #[inline]
    pub(super) fn parse_Split<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Split> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), ',') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '，') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Split" }))
    }
}
