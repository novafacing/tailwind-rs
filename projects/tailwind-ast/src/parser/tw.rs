// This file was generated by Peginator v0.3.0
// Hash of the grammar file: 451119FFC604DADEC3DDF6E97384686EBD2196E85CF1A944D110EB649ED61EB6
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct TwParser {
    pub statements: Vec<TwStatementNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum TwStatementNode {
    GroupNode(GroupNode),
    InstructNode(InstructNode),
}
#[derive(Debug, Clone)]
pub struct GroupNode {
    pub head: InstructNode,
    pub statements: Vec<TwStatementNode>,
    pub important: Option<Important>,
}
#[derive(Debug, Clone)]
pub struct InstructNode {
    pub pseudo: Option<IdentifierNode>,
    pub instructs: Vec<IdentifierNode>,
    pub important: Option<Important>,
}
pub type Pseudo = String;
#[derive(Debug, Clone)]
pub struct Hyphen;
#[derive(Debug, Clone)]
pub struct Important;
pub type IdentifierNode = String;
#[derive(Debug, Clone)]
pub struct Dot;
#[derive(Debug, Clone)]
pub struct Split;
impl peginator_generated::PegParser for TwParser {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_TwParser(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{
        IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod TwParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut statements, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<TwStatementNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwParser> {
            let result = parse(state, tracer, cache)?.map(|r| super::TwParser { statements: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwParser<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwParser> {
        tracer.run_traced("TwParser", state, |state, tracer| {
            TwParser_impl::rule_parser(state, tracer, cache)
        })
    }
    mod TwStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GroupNode(state, tracer, cache))
                        .map_inner(Parsed__override::GroupNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_InstructNode(state, tracer, cache))
                        .map_inner(Parsed__override::InstructNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::TwStatementNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwStatementNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwStatementNode> {
        tracer.run_traced("TwStatementNode", state, |state, tracer| {
            TwStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod GroupNode_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: head, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_InstructNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: mut statements, state } = part_3::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { head, statements, important }, state })
        }
        pub struct Parsed {
            pub head: InstructNode,
            pub statements: Vec<TwStatementNode>,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GroupNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::GroupNode {
                head: r.head,
                statements: r.statements,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GroupNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GroupNode> {
        tracer.run_traced("GroupNode", state, |state, tracer| {
            GroupNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod InstructNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { result: pseudo, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_IdentifierNode(state, tracer, cache)
                        })
                        .map_inner(Some)?;
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Pseudo(state, tracer, cache))
                        .discard_result()?;
                    Ok(ParseOk { result: pseudo, state })
                }
                pub type Parsed = Option<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache).or_else(|err| {
                    Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                })
            }
            pub type Parsed = Option<IdentifierNode>;
        }
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                        .discard_result()?;
                    let ParseOk { result: mut instructs, state } =
                        parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| {
                                parse_IdentifierNode(state, tracer, cache)
                            })
                            .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: instructs, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut instructs: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            instructs.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: instructs, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: pseudo, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { result: mut instructs, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_instructs_with, state } =
                part_2::parse(state, tracer, cache)?;
            instructs.extend(extend_instructs_with);
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { pseudo, instructs, important }, state })
        }
        pub struct Parsed {
            pub pseudo: Option<IdentifierNode>,
            pub instructs: Vec<IdentifierNode>,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::InstructNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::InstructNode {
                pseudo: r.pseudo,
                instructs: r.instructs,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_InstructNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, InstructNode> {
        tracer.run_traced("InstructNode", state, |state, tracer| {
            InstructNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Pseudo_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Pseudo> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Pseudo<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Pseudo> {
        tracer.run_traced("Pseudo", state, |state, tracer| {
            Pseudo_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Hyphen_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Hyphen> {
            let result = parse(state, tracer, cache)?.map(|r| super::Hyphen {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Hyphen<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Hyphen> {
        tracer.run_traced("Hyphen", state, |state, tracer| {
            Hyphen_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Important_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Important> {
            let result = parse(state, tracer, cache)?.map(|r| super::Important {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Important<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Important> {
        tracer.run_traced("Important", state, |state, tracer| {
            Important_impl::rule_parser(state, tracer, cache)
        })
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, IdentifierNode> {
        match crate::eat_css_class(state.s()) {
            Ok((result, advance)) => {
                Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) })
            }
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed {
                function_name: "crate::eat_css_class",
                error_string,
            })),
        }
    }
    mod Dot_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '。'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Dot> {
            let result = parse(state, tracer, cache)?.map(|r| super::Dot {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Dot<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Dot> {
        tracer.run_traced("Dot", state, |state, tracer| Dot_impl::rule_parser(state, tracer, cache))
    }
    mod Split_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ';'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '，'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Split> {
            let result = parse(state, tracer, cache)?.map(|r| super::Split {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Split<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Split> {
        tracer.run_traced("Split", state, |state, tracer| {
            Split_impl::rule_parser(state, tracer, cache)
        })
    }
}
