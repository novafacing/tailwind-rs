// This file was generated by Peginator v0.3.0
// Hash of the grammar file: 83F83CB5C25A23848B16089841E782F1DD88178D629B9B42931AD42C05E18812
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct TwParser {
    pub statements: Vec<TwStatementNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum TwStatementNode {
    ArbitraryNode(ArbitraryNode),
    GroupNode(GroupNode),
    InstructNode(InstructNode),
}
#[derive(Debug, Clone)]
pub struct GroupNode {
    pub variant: Option<VariantNode>,
    pub element: ElementNode,
    pub statements: Vec<TwStatementNode>,
    pub important: Option<Important>,
}
#[derive(Debug, Clone)]
pub struct ArbitraryNode {
    pub variant: Option<VariantNode>,
    pub element: ElementNode,
    pub item: ArbitraryItem,
    pub important: Option<Important>,
}
#[derive(Debug, Clone)]
pub struct InstructNode {
    pub variant: Option<VariantNode>,
    pub element: ElementNode,
    pub important: Option<Important>,
}
#[derive(Debug, Clone)]
pub struct VariantNode {
    pub items: Vec<VariantItemNode>,
}
#[derive(Debug, Clone)]
pub struct VariantItemNode {
    pub not: Option<Not>,
    pub element: ElementNode,
    pub pseudo: Pseudo,
}
#[derive(Debug, Clone)]
pub struct ElementNode {
    pub negative: Option<Hyphen>,
    pub identifiers: Vec<IdentifierNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ArbitraryItem {
    ArbitraryBalance(ArbitraryBalance),
    StringNode(StringNode),
}
pub type ArbitraryBalance = String;
#[derive(Debug, Clone)]
pub struct StringNode {
    pub item: Vec<StringItem>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    Any(Any),
    Escaped(Escaped),
}
#[derive(Debug, Clone)]
pub struct Escaped {
    pub any: char,
}
pub type Any = char;
pub type Pseudo = String;
#[derive(Debug, Clone)]
pub struct Hyphen;
#[derive(Debug, Clone)]
pub struct Important;
#[derive(Debug, Clone)]
pub struct Not;
pub type IdentifierNode = String;
#[derive(Debug, Clone)]
pub struct Dot;
#[derive(Debug, Clone)]
pub struct Split;
impl peginator_generated::PegParser for TwParser {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_TwParser(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{
        IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod TwParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut statements, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<TwStatementNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwParser> {
            let result = parse(state, tracer, cache)?.map(|r| super::TwParser { statements: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwParser<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwParser> {
        tracer.run_traced("TwParser", state, |state, tracer| {
            TwParser_impl::rule_parser(state, tracer, cache)
        })
    }
    mod TwStatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_GroupNode(state, tracer, cache))
                        .map_inner(Parsed__override::GroupNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ArbitraryNode(state, tracer, cache))
                        .map_inner(Parsed__override::ArbitraryNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_InstructNode(state, tracer, cache))
                        .map_inner(Parsed__override::InstructNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::TwStatementNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::TwStatementNode> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_TwStatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, TwStatementNode> {
        tracer.run_traced("TwStatementNode", state, |state, tracer| {
            TwStatementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod GroupNode_impl {
        use super::*;
        mod part_4 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<TwStatementNode> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_TwStatementNode(state, tracer, cache)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<TwStatementNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: variant, state } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_VariantNode(state, tracer, cache))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                })?;
            let ParseOk { result: element, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ElementNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: mut statements, state } = part_4::parse(state, tracer, cache)?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { variant, element, statements, important }, state })
        }
        pub struct Parsed {
            pub variant: Option<VariantNode>,
            pub element: ElementNode,
            pub statements: Vec<TwStatementNode>,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::GroupNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::GroupNode {
                variant: r.variant,
                element: r.element,
                statements: r.statements,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_GroupNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, GroupNode> {
        tracer.run_traced("GroupNode", state, |state, tracer| {
            GroupNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod ArbitraryNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: variant, state } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_VariantNode(state, tracer, cache))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                })?;
            let ParseOk { result: element, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ElementNode(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                .discard_result()?;
            let ParseOk { result: item, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ArbitraryItem(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                .discard_result()?;
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { variant, element, item, important }, state })
        }
        pub struct Parsed {
            pub variant: Option<VariantNode>,
            pub element: ElementNode,
            pub item: ArbitraryItem,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ArbitraryNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::ArbitraryNode {
                variant: r.variant,
                element: r.element,
                item: r.item,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ArbitraryNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ArbitraryNode> {
        tracer.run_traced("ArbitraryNode", state, |state, tracer| {
            ArbitraryNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod InstructNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: variant, state } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_VariantNode(state, tracer, cache))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                })?;
            let ParseOk { result: element, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ElementNode(state, tracer, cache))?;
            let ParseOk { result: important, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Important(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            Ok(ParseOk { result: Parsed { variant, element, important }, state })
        }
        pub struct Parsed {
            pub variant: Option<VariantNode>,
            pub element: ElementNode,
            pub important: Option<Important>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::InstructNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::InstructNode {
                variant: r.variant,
                element: r.element,
                important: r.important,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_InstructNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, InstructNode> {
        tracer.run_traced("InstructNode", state, |state, tracer| {
            InstructNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod VariantNode_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut items: Vec<VariantItemNode> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_VariantItemNode(state, tracer, cache))
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        items.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: items, state })
        }
        pub type Parsed = Vec<VariantItemNode>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::VariantNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::VariantNode { items: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_VariantNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, VariantNode> {
        tracer.run_traced("VariantNode", state, |state, tracer| {
            VariantNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod VariantItemNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { result: not, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Not(state, tracer, cache))
                        .map_inner(Some)?;
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                        .discard_result()?;
                    Ok(ParseOk { result: not, state })
                }
                pub type Parsed = Option<Not>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache).or_else(|err| {
                    Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                })
            }
            pub type Parsed = Option<Not>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: not, state } = part_0::parse(state, tracer, cache)?;
            let ParseOk { result: element, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ElementNode(state, tracer, cache))?;
            let ParseOk { result: pseudo, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_Pseudo(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { not, element, pseudo }, state })
        }
        pub struct Parsed {
            pub not: Option<Not>,
            pub element: ElementNode,
            pub pseudo: Pseudo,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::VariantItemNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::VariantItemNode {
                not: r.not,
                element: r.element,
                pseudo: r.pseudo,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_VariantItemNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, VariantItemNode> {
        tracer.run_traced("VariantItemNode", state, |state, tracer| {
            VariantItemNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod ElementNode_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                        .discard_result()?;
                    let ParseOk { result: mut identifiers, state } =
                        parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| {
                                parse_IdentifierNode(state, tracer, cache)
                            })
                            .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: identifiers, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut identifiers: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            identifiers.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: identifiers, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: negative, state } =
                parse_Whitespace(state.clone(), tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Hyphen(state, tracer, cache))
                    .map_inner(Some)
                    .or_else(|err| {
                        Ok(ParseOk { result: Default::default(), state: state.record_error(err) })
                    })?;
            let ParseOk { result: mut identifiers, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, tracer, cache))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_identifiers_with, state } =
                part_2::parse(state, tracer, cache)?;
            identifiers.extend(extend_identifiers_with);
            Ok(ParseOk { result: Parsed { negative, identifiers }, state })
        }
        pub struct Parsed {
            pub negative: Option<Hyphen>,
            pub identifiers: Vec<IdentifierNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ElementNode> {
            let result = parse(state, tracer, cache)?
                .map(|r| super::ElementNode { negative: r.negative, identifiers: r.identifiers });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ElementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ElementNode> {
        tracer.run_traced("ElementNode", state, |state, tracer| {
            ElementNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod ArbitraryItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, tracer, cache))
                        .map_inner(Parsed__override::StringNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| {
                            parse_ArbitraryBalance(state, tracer, cache)
                        })
                        .map_inner(Parsed__override::ArbitraryBalance)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ArbitraryItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ArbitraryItem> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ArbitraryItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ArbitraryItem> {
        tracer.run_traced("ArbitraryItem", state, |state, tracer| {
            ArbitraryItem_impl::rule_parser(state, tracer, cache)
        })
    }
    #[inline]
    pub(super) fn parse_ArbitraryBalance<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ArbitraryBalance> {
        match crate::eat_arbitrary(state.s()) {
            Ok((result, advance)) => {
                Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) })
            }
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed {
                function_name: "crate::eat_arbitrary",
                error_string,
            })),
        }
    }
    mod StringNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(
                                state: ParseState<'a>,
                                tracer: impl ParseTracer,
                                cache: &mut ParseCache<'a>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_character_literal(state, '\'').discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, tracer, cache)?;
                        let ParseOk { result: mut item, state } =
                            parse_StringItem(state, tracer, cache)
                                .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: item, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut item: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                item.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: item, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } =
                    parse_character_literal(state, '\'').discard_result()?;
                let ParseOk { result: mut item, state } = part_1::parse(state, tracer, cache)?;
                let ParseOk { state, .. } =
                    parse_character_literal(state, '\'').discard_result()?;
                Ok(ParseOk { result: item, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(
                                state: ParseState<'a>,
                                tracer: impl ParseTracer,
                                cache: &mut ParseCache<'a>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_character_literal(state, '"').discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, tracer, cache)?;
                        let ParseOk { result: mut item, state } =
                            parse_StringItem(state, tracer, cache)
                                .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: item, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut item: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                item.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: item, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
                let ParseOk { result: mut item, state } = part_1::parse(state, tracer, cache)?;
                let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
                Ok(ParseOk { result: item, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state.clone(), tracer, cache))
                .choice(|state| choice_1::parse(state.clone(), tracer, cache))
                .end()
        }
        pub type Parsed = Vec<StringItem>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StringNode> {
            let result = parse(state, tracer, cache)?.map(|r| super::StringNode { item: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StringNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StringNode> {
        tracer.run_traced("StringNode", state, |state, tracer| {
            StringNode_impl::rule_parser(state, tracer, cache)
        })
    }
    mod StringItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Escaped(state, tracer, cache))
                        .map_inner(Parsed__override::Escaped)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Any(state, tracer, cache))
                        .map_inner(Parsed__override::Any)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StringItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StringItem> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StringItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StringItem> {
        tracer.run_traced("StringItem", state, |state, tracer| {
            StringItem_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Escaped_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { result: any, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_char(state, tracer, cache))?;
            Ok(ParseOk { result: any, state })
        }
        pub type Parsed = char;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Escaped> {
            let result = parse(state, tracer, cache)?.map(|r| super::Escaped { any: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Escaped<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Escaped> {
        tracer.run_traced("Escaped", state, |state, tracer| {
            Escaped_impl::rule_parser(state, tracer, cache)
        })
    }
    #[inline]
    pub(super) fn parse_Any<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Any> {
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Any" }))
    }
    mod Pseudo_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Pseudo> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Pseudo<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Pseudo> {
        tracer.run_traced("Pseudo", state, |state, tracer| {
            Pseudo_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Hyphen_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Hyphen> {
            let result = parse(state, tracer, cache)?.map(|r| super::Hyphen {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Hyphen<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Hyphen> {
        tracer.run_traced("Hyphen", state, |state, tracer| {
            Hyphen_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Important_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Important> {
            let result = parse(state, tracer, cache)?.map(|r| super::Important {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Important<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Important> {
        tracer.run_traced("Important", state, |state, tracer| {
            Important_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Not_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "not"))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Not> {
            let result = parse(state, tracer, cache)?.map(|r| super::Not {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Not<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Not> {
        tracer.run_traced("Not", state, |state, tracer| Not_impl::rule_parser(state, tracer, cache))
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, IdentifierNode> {
        match crate::eat_css_class(state.s()) {
            Ok((result, advance)) => {
                Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) })
            }
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed {
                function_name: "crate::eat_css_class",
                error_string,
            })),
        }
    }
    mod Dot_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '。'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Dot> {
            let result = parse(state, tracer, cache)?.map(|r| super::Dot {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Dot<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Dot> {
        tracer.run_traced("Dot", state, |state, tracer| Dot_impl::rule_parser(state, tracer, cache))
    }
    mod Split_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ';'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '，'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Split> {
            let result = parse(state, tracer, cache)?.map(|r| super::Split {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Split<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Split> {
        tracer.run_traced("Split", state, |state, tracer| {
            Split_impl::rule_parser(state, tracer, cache)
        })
    }
}
